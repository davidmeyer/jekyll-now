<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
    <meta name="description" content="Developing Problem Statements David Meyer Cisco Routing &amp; Addressing Workshop 20-22 Feb 2007 Herndon, VA Agenda Scope Brief History of the (R&amp;A) Universe Hot Boxes and Hot Wires Characterizing Architectural Models Discussion Scope Session Objective:  To outline which problems in the Routing and Addressing space, if any, we might take on On key observation on all of this:  TANSTAAFL The Ain’t No Such Thing As A Free Lunch Structured as a discussion And which architectural models we want to look at? And in which timeframes  And in which, if any, venues? This is an academic exercise if we never deploy anything Brief History of the R&amp;A Universe BGP remains largely unchanged (circa 1994) Concern about growth of the DFZ RIB In particular, due to multihoming, and traffic engineering (TE)  IAB R&amp;A Workshop -- 10/2006 SPs voiced concern over the trajectory and properties of the DFZ RIB Lots of discussion since, little clarity on what is a problem and what isn’t And as a result, little work on solution spaces I* analysis paralysis  Hot Boxes and Hot Wires1 Hot Boxes Do trends allow continued scaling of the (DFZ) RIB at the present rate? If not, does the RIB have to scale sub-linearly in the number of end sites? If so... Would that break multihoming via PI? And how do you do TE w/o more specifics? Or server referrals (for the content folks)? Hot Wires Will BGP (UPDATE) dynamics kill us even if the RIB size is “controlled”?  [1]  Terminology due to Brian Carpenter Is there really a Hot Box Problem? Issue: Growth of the RIB Is this a real problem? http://www.nanog.org/mtg-0702/presentations/fib-scudder.pdf suggests its not Conclusion of those slides The problem is solvable, in some time frame, by either adding more memory, and/or by changing our engineering practices (e.g., BGP free core), and/or by social engineering (eliminating the influence of bad actors) Q: Can we have the DFZ RIB grow at current rates and still scale the control plane at constant cost? This was the point raised by tli at the AMS workshop Various opinions on this one Is there really a Hot Wires Problem? Issue: BGP UPDATE Dynamics The core network can be exposed to “edge dynamics” by virtue of the fine grained information being carried by the routing system (according to gih, the “core” is relatively stable) Of course, this is related to the size of the DFZ RIB And if there is some kind of Long Range Dependency (LRD)1, these dynamics could be “non-linearly cumulative” Route Flap Dampening  was a proposed solution, but that had a negative impact on the Internet’s ability to respond to real topological changes 1 i.e., Is the UPDATE time-series is a long memory process (events at a time index in the past       effect current events, independent of the “lag”)? On Observing The Hot Wires Problem Anecdotal Evidence Example: Baltimore Tunnel Fire and the ensuing instability Historical Control Plane “Traces” i.e., Routing data No one (to my knowledge) has rigorously characterized the “burstiness” of the UPDATE stream A good start is in “Modeling BGP Table Fluctuations”, Flavel, et al.  There is some research that suggests that the UPDATE stream is heavy tailed (see http://www.potaroo.net) Would have to measure the Hurst parameter (H) or the like (H is a statistical measure describing persistent correlations) Summary:  The Hot Wires Problem While we don’t really know if there is LRD in the UPDATE stream,  if it is present, its unlikely to be characterized by a “simple” H value1  i.e., discovering LRD in the UPDATE stream would require a non-trivial study More study needed 1 See, e.g., http://www.richardclegg.org/pubs/rgc_ukpewtalk05.pdf Characterizing the Solution Space: Architectural Perspectives We will be focusing here on namespaces, and the various options for syntax and semantics of those namespaces (locators and identifiers) This is not to say that there aren’t solutions that don’t necessarily involve unwinding the overloading of IP addresses For example, perhaps some form of compact routing? Noting that there are name-independent forms of compact routing that do implement a form of loc/id split See, e.g.,  “Compact Routing on Internet-Like Graphs”,  Krioukov, et. al. http://berkeley.intel-reserach.net/kfall/page/crig-infocom.pdf Characterizing the Solution Space: Architectural Perspectives There will be little (or no) discussion of routing algorithms in the rest of this talk, in large part Because the fundamental problems (e.g., information complexity, amount of data, etc) are relatively insensitive to the routing algorithm You can think about these problems in either the distance vector,  link state, or path vector contexts and arrive at similar results So lets dive in... Characterizing the Solution Space: Architectural Perspectives First,  are we planning to use the existing routing-name name-space? If so, implies natural limits on what is possible Example: Incremental improvements to BGP Perhaps that is the best we can do... See Mark Handley’s “The Internet Only Just Works” And can we make sense out of using the existing routing-name namespace and re-architecting the allocations? CIDR v2? Well, no... Characterizing the Solution Space: New Namespaces Which namespaces? Locators  “where” (to a first approximation) Identifiers  “who” (to a first approximation) Really two cases here:  The new namespace is not visible to hosts The new namespace is visible to hosts Deploying a new namespace that is not visible to hosts In this case mapping boxes are deployed at the customer edge (CE or PE) to encapsulate packets as they head to towards the core  Has the advantage that we can move forward without host modifications Has a two main sub-cases, depending on the syntax of the new namespace. Either  The syntax of the new namespace is the same as an existing namespace The syntax of the new namespace is different than an existing namespace Case 1: The new namespace has the same syntax as an existing namespace  Candidate namespaces: IPv4 and/or IPv6 Has several advantages, including Can use existing h/w and s/w in the core Only the mapping boxes have new code Has various problems in the “half-deployed” state, since you have to carry the old and new names See draft-nikander-ram-generix-proxying-00.txt David Conrad’s presentation from the AMS workshop outlined this approach LISP is an instance of this approach Case 2: The new namespace has a new syntax Examples NIMROD MPLS? Well, it is a new layer with a new syntax  In this case, both the core and the edges need to be changed Deploying a new namespace that is visible to hosts In this case a new namespace is deployed, and the hosts see it, so there will need to be changes to hosts Issue:  What about the whole transition/coexistence space, and is if we never get to IPv6, are IPv6-only solutions of interest (for example, SHIM6)? The new namespace can have the same sub-cases (same syntax or not), but this is less important here as you have to modify the hosts in any event Examples include SHIM6 and HIP, and GSE GSE is kind of a hybrid (Dino will talk about this)  From the “Layers” Perspective Basically, you have an existing namespace which does two things: identification and location You can migrate one or both of these functions to a new namespace, with the new namespace inserted either above or below the “old” internetwork layer If the new namespace is “above” the old internetwork layer, applications and/or transport must be modified to use the new namespace If the new namespace is “below” the old internetwork layer, then you have to “jack up”1 the existing internetwork layer 1 The term “jack up” is due to Noel Chiappa New namespace inserted above “old” internetwork layer 1 As Pekka Nikander has observed, the separation of location and identification can be made at (at least) 3 different locations in the IP stack:  Above the transport layer,  in the transport layer,  or in the network. Applications/transport are modified to use new namespace1 Essentially adds a new end-to-end naming layer Examples include SCTP, HIP and SHIM6 SHIM6 keeps the old syntax, minimizing code changes; HIP has a new namespace, but provides a local mapping from the old namespace(s) to the new (again, minimizing code changes) Identifiers MAP(ID,Loc) somewhere in here Locators New namespace inserted below “old” internetwork layer Applications and/or transport use old namespace In this case,  the old internetwork layer is “jacked up” and a new namespace and internetwork layer are inserted  below it The old internetwork layer becomes an end-to-end naming layer Rewriting “in the network” somewhere  Old Internetwork layer “jacked up” to allow insertion of the new namespace A Third Possibility Jim Bound has also suggested that one might try to migrate both location and identity out to new, specialized namespaces  This has the effect of eventually either abandoning the existing IPv4 namespace entirely, or perhaps keeping the IPv4 space for scope local forwarding  Not a fleshed out idea YAWTLAT1 Approach	Encap	Protocol	Security LISP	IP Tunnel	ICMP/New	undefined SHIM6	Context Tag	SHIM6	HBA/CBA + RR HIP	IPsec ESP	HIP BE	ORCHID + RR 1Chart due to Pekka Nikander (see ram@iab.org); see also draft-nikander-ram-generix-proxying-00.txt Aside: Interesting Alternative Model1 Use MPLS, augmented with a new routing-name namespace BTW, MPLS could be considered to be in the “Not visible to hosts but with a new syntax” class of namespaces The idea would be to split the internetwork layer into a “host-to-first-hop-router” protocol and a “router-to-router” protocol  This model is in “jack up” class of schemes, and posits a different architectural model for the internetwork layer to allow for easier TE and aggregation 1Suggested in conversations with Noel Chiappa Other issues in the Loc/ID split space1 Do we need to allocate IDs in an aggregatable fashion? Are IDs routable in some scope? Perhaps with a different AFI/SAFI? Secure Locator/ID mapping service? Can Unidirectional Mapping help? ID -&gt; Locator, but not the reverse? Can DHT’s be used for this purpose? or the DNS? or Return Routing (RR)? 1 NACL (Not A Complete List) Other issues in the Loc/ID split space1 More generally, can we preserve secure end to end identity in the presence of loc/id split? And what about TE? Presumably, part of the reason to do this is to be able aggregate.  If we don’t carry more specifics, then how do we do TE? SPs seem to be wedged on the TE front:  In particular, they need more specifics for TE,  while at the same time they don’t want more specifics as they cause bloat in various places (e.g., RIBs) 1 NACL (Not A Complete List) So, Problem Set... Are there models that are missing here? Which model(s) do we want to attack? And how do we gain critical mass? “Deployment Wins” -- tli And in which timeframes? And what about “incremental solutions” e.g., FIB compression techniques YATSTF (Yet Another Time/Space Tradeoff) Note:  FIB non-determinism? Incremental UPDATES? Discussion"/>
    <title></title>
    <script type="text/javascript" language="javascript">
//      <![CDATA[
            var images = new Array (26);
            images[0] = "developing_problem_statements.001.png";
            images[1] = "developing_problem_statements.002.png";
            images[2] = "developing_problem_statements.003.png";
            images[3] = "developing_problem_statements.004.png";
            images[4] = "developing_problem_statements.005.png";
            images[5] = "developing_problem_statements.006.png";
            images[6] = "developing_problem_statements.007.png";
            images[7] = "developing_problem_statements.008.png";
            images[8] = "developing_problem_statements.009.png";
            images[9] = "developing_problem_statements.010.png";
            images[10] = "developing_problem_statements.011.png";
            images[11] = "developing_problem_statements.012.png";
            images[12] = "developing_problem_statements.013.png";
            images[13] = "developing_problem_statements.014.png";
            images[14] = "developing_problem_statements.015.png";
            images[15] = "developing_problem_statements.016.png";
            images[16] = "developing_problem_statements.017.png";
            images[17] = "developing_problem_statements.018.png";
            images[18] = "developing_problem_statements.019.png";
            images[19] = "developing_problem_statements.020.png";
            images[20] = "developing_problem_statements.021.png";
            images[21] = "developing_problem_statements.022.png";
            images[22] = "developing_problem_statements.023.png";
            images[23] = "developing_problem_statements.024.png";
            images[24] = "developing_problem_statements.025.png";
            images[25] = "developing_problem_statements.026.png";
            var index = 0;
            function WindowLoaded(evt)
            {
                document.body.onselectstart = function () { return false; };
            }
            function Step(i)
            {
                GoTo(index + i)
            }
            function GoTo(newIndex)
            {
                if(newIndex >= 0 && newIndex < images.length)
                {
                    index = newIndex;
                    document.Slideshow.src = images[index];
                }
            }
//      ]]>
    </script>
</head>
<body bgcolor="black" onload='WindowLoaded(event);'>
    <p align="center">
        <br/>
        <br/>
        <img name="Slideshow" alt="" src="developing_problem_statements.001.png" onclick="Step(1)"/>
        <br/>
        <br/>
        <input type="image" src="home.png" onclick="GoTo(0)"/>
        &nbsp;&nbsp;&nbsp;
        <input type="image" src="prev.png" onclick="Step(-1)"/>
        <input type="image" src="next.png" onclick="Step(1)"/>
    </p>
</body>
</html>
